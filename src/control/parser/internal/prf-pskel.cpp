// Copyright (C) 2005-2010 Code Synthesis Tools CC
//
// This program was generated by CodeSynthesis XSD, an XML Schema to
// C++ data binding compiler.
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License version 2 as
// published by the Free Software Foundation.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA
//
// In addition, as a special exception, Code Synthesis Tools CC gives
// permission to link this program with the Xerces-C++ library (or with
// modified versions of Xerces-C++ that use the same license as Xerces-C++),
// and distribute linked combinations including the two. You must obey
// the GNU General Public License version 2 in all respects for all of
// the code used other than Xerces-C++. If you modify this copy of the
// program, you may extend this exception to your version of the program,
// but you are not obligated to do so. If you do not wish to do so, delete
// this exception statement from your version.
//
// Furthermore, Code Synthesis Tools CC makes a special exception for
// the Free/Libre and Open Source Software (FLOSS) which is described
// in the accompanying FLOSSE file.
//

// Begin prologue.
//
//
// End prologue.

#include "prf-pskel.h"

namespace prf
{
  // action_pskel
  //

  void action_pskel::
  type_parser (::prf::ActionType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void action_pskel::
  parsers (::prf::ActionType_pskel& type)
  {
    this->type_parser_ = &type;
  }

  action_pskel::
  action_pskel ()
  : type_parser_ (0)
  {
  }

  // configurationKind_pskel
  //

  void configurationKind_pskel::
  kindtype_parser (::prf::StructPropertyConfigurationType_pskel& p)
  {
    this->kindtype_parser_ = &p;
  }

  void configurationKind_pskel::
  parsers (::prf::StructPropertyConfigurationType_pskel& kindtype)
  {
    this->kindtype_parser_ = &kindtype;
  }

  configurationKind_pskel::
  configurationKind_pskel ()
  : kindtype_parser_ (0)
  {
  }

  // enumeration_pskel
  //

  void enumeration_pskel::
  label_parser (::xml_schema::string_pskel& p)
  {
    this->label_parser_ = &p;
  }

  void enumeration_pskel::
  value_parser (::xml_schema::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void enumeration_pskel::
  parsers (::xml_schema::string_pskel& label,
           ::xml_schema::string_pskel& value)
  {
    this->label_parser_ = &label;
    this->value_parser_ = &value;
  }

  enumeration_pskel::
  enumeration_pskel ()
  : label_parser_ (0),
    value_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // enumerations_pskel
  //

  void enumerations_pskel::
  enumeration_parser (::prf::enumeration_pskel& p)
  {
    this->enumeration_parser_ = &p;
  }

  void enumerations_pskel::
  parsers (::prf::enumeration_pskel& enumeration)
  {
    this->enumeration_parser_ = &enumeration;
  }

  enumerations_pskel::
  enumerations_pskel ()
  : enumeration_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // inputValue_pskel
  //

  void inputValue_pskel::
  simple_parser (::prf::simple_pskel& p)
  {
    this->simple_parser_ = &p;
  }

  void inputValue_pskel::
  parsers (::prf::simple_pskel& simple)
  {
    this->simple_parser_ = &simple;
  }

  inputValue_pskel::
  inputValue_pskel ()
  : simple_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // kind_pskel
  //

  void kind_pskel::
  kindtype_parser (::prf::PropertyConfigurationType_pskel& p)
  {
    this->kindtype_parser_ = &p;
  }

  void kind_pskel::
  parsers (::prf::PropertyConfigurationType_pskel& kindtype)
  {
    this->kindtype_parser_ = &kindtype;
  }

  kind_pskel::
  kind_pskel ()
  : kindtype_parser_ (0)
  {
  }

  // properties_pskel
  //

  void properties_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void properties_pskel::
  simple_parser (::prf::simple_pskel& p)
  {
    this->simple_parser_ = &p;
  }

  void properties_pskel::
  simplesequence_parser (::prf::simpleSequence_pskel& p)
  {
    this->simplesequence_parser_ = &p;
  }

  void properties_pskel::
  test_parser (::prf::test_pskel& p)
  {
    this->test_parser_ = &p;
  }

  void properties_pskel::
  struct_parser (::prf::struct_pskel& p)
  {
    this->struct__parser_ = &p;
  }

  void properties_pskel::
  structsequence_parser (::prf::structSequence_pskel& p)
  {
    this->structsequence_parser_ = &p;
  }

  void properties_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::prf::simple_pskel& simple,
           ::prf::simpleSequence_pskel& simplesequence,
           ::prf::test_pskel& test,
           ::prf::struct_pskel& struct_,
           ::prf::structSequence_pskel& structsequence)
  {
    this->description_parser_ = &description;
    this->simple_parser_ = &simple;
    this->simplesequence_parser_ = &simplesequence;
    this->test_parser_ = &test;
    this->struct__parser_ = &struct_;
    this->structsequence_parser_ = &structsequence;
  }

  properties_pskel::
  properties_pskel ()
  : description_parser_ (0),
    simple_parser_ (0),
    simplesequence_parser_ (0),
    test_parser_ (0),
    struct__parser_ (0),
    structsequence_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // range_pskel
  //

  void range_pskel::
  max_parser (::xml_schema::string_pskel& p)
  {
    this->max_parser_ = &p;
  }

  void range_pskel::
  min_parser (::xml_schema::string_pskel& p)
  {
    this->min_parser_ = &p;
  }

  void range_pskel::
  parsers (::xml_schema::string_pskel& max,
           ::xml_schema::string_pskel& min)
  {
    this->max_parser_ = &max;
    this->min_parser_ = &min;
  }

  range_pskel::
  range_pskel ()
  : max_parser_ (0),
    min_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // resultValue_pskel
  //

  void resultValue_pskel::
  simple_parser (::prf::simple_pskel& p)
  {
    this->simple_parser_ = &p;
  }

  void resultValue_pskel::
  parsers (::prf::simple_pskel& simple)
  {
    this->simple_parser_ = &simple;
  }

  resultValue_pskel::
  resultValue_pskel ()
  : simple_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // simple_pskel
  //

  void simple_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void simple_pskel::
  value_parser (::xml_schema::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void simple_pskel::
  units_parser (::prf::Unit_pskel& p)
  {
    this->units_parser_ = &p;
  }

  void simple_pskel::
  range_parser (::prf::range_pskel& p)
  {
    this->range_parser_ = &p;
  }

  void simple_pskel::
  enumerations_parser (::prf::enumerations_pskel& p)
  {
    this->enumerations_parser_ = &p;
  }

  void simple_pskel::
  kind_parser (::prf::kind_pskel& p)
  {
    this->kind_parser_ = &p;
  }

  void simple_pskel::
  action_parser (::prf::action_pskel& p)
  {
    this->action_parser_ = &p;
  }

  void simple_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void simple_pskel::
  mode_parser (::prf::AccessType_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void simple_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void simple_pskel::
  complex_parser (::prf::IsComplex_pskel& p)
  {
    this->complex_parser_ = &p;
  }

  void simple_pskel::
  type_parser (::prf::PropertyValueType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void simple_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::xml_schema::string_pskel& value,
           ::prf::Unit_pskel& units,
           ::prf::range_pskel& range,
           ::prf::enumerations_pskel& enumerations,
           ::prf::kind_pskel& kind,
           ::prf::action_pskel& action,
           ::xml_schema::string_pskel& id,
           ::prf::AccessType_pskel& mode,
           ::xml_schema::string_pskel& name,
           ::prf::IsComplex_pskel& complex,
           ::prf::PropertyValueType_pskel& type)
  {
    this->description_parser_ = &description;
    this->value_parser_ = &value;
    this->units_parser_ = &units;
    this->range_parser_ = &range;
    this->enumerations_parser_ = &enumerations;
    this->kind_parser_ = &kind;
    this->action_parser_ = &action;
    this->id_parser_ = &id;
    this->mode_parser_ = &mode;
    this->name_parser_ = &name;
    this->complex_parser_ = &complex;
    this->type_parser_ = &type;
  }

  simple_pskel::
  simple_pskel ()
  : description_parser_ (0),
    value_parser_ (0),
    units_parser_ (0),
    range_parser_ (0),
    enumerations_parser_ (0),
    kind_parser_ (0),
    action_parser_ (0),
    id_parser_ (0),
    mode_parser_ (0),
    name_parser_ (0),
    complex_parser_ (0),
    type_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // simpleRef_pskel
  //

  void simpleRef_pskel::
  refid_parser (::xml_schema::string_pskel& p)
  {
    this->refid_parser_ = &p;
  }

  void simpleRef_pskel::
  value_parser (::xml_schema::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void simpleRef_pskel::
  parsers (::xml_schema::string_pskel& refid,
           ::xml_schema::string_pskel& value)
  {
    this->refid_parser_ = &refid;
    this->value_parser_ = &value;
  }

  simpleRef_pskel::
  simpleRef_pskel ()
  : refid_parser_ (0),
    value_parser_ (0),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // simpleSequence_pskel
  //

  void simpleSequence_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void simpleSequence_pskel::
  values_parser (::prf::values_pskel& p)
  {
    this->values_parser_ = &p;
  }

  void simpleSequence_pskel::
  units_parser (::prf::Unit_pskel& p)
  {
    this->units_parser_ = &p;
  }

  void simpleSequence_pskel::
  range_parser (::prf::range_pskel& p)
  {
    this->range_parser_ = &p;
  }

  void simpleSequence_pskel::
  kind_parser (::prf::kind_pskel& p)
  {
    this->kind_parser_ = &p;
  }

  void simpleSequence_pskel::
  action_parser (::prf::action_pskel& p)
  {
    this->action_parser_ = &p;
  }

  void simpleSequence_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void simpleSequence_pskel::
  mode_parser (::prf::AccessType_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void simpleSequence_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void simpleSequence_pskel::
  type_parser (::prf::PropertyValueType_pskel& p)
  {
    this->type_parser_ = &p;
  }

  void simpleSequence_pskel::
  complex_parser (::prf::IsComplex_pskel& p)
  {
    this->complex_parser_ = &p;
  }

  void simpleSequence_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::prf::values_pskel& values,
           ::prf::Unit_pskel& units,
           ::prf::range_pskel& range,
           ::prf::kind_pskel& kind,
           ::prf::action_pskel& action,
           ::xml_schema::string_pskel& id,
           ::prf::AccessType_pskel& mode,
           ::xml_schema::string_pskel& name,
           ::prf::PropertyValueType_pskel& type,
           ::prf::IsComplex_pskel& complex)
  {
    this->description_parser_ = &description;
    this->values_parser_ = &values;
    this->units_parser_ = &units;
    this->range_parser_ = &range;
    this->kind_parser_ = &kind;
    this->action_parser_ = &action;
    this->id_parser_ = &id;
    this->mode_parser_ = &mode;
    this->name_parser_ = &name;
    this->type_parser_ = &type;
    this->complex_parser_ = &complex;
  }

  simpleSequence_pskel::
  simpleSequence_pskel ()
  : description_parser_ (0),
    values_parser_ (0),
    units_parser_ (0),
    range_parser_ (0),
    kind_parser_ (0),
    action_parser_ (0),
    id_parser_ (0),
    mode_parser_ (0),
    name_parser_ (0),
    type_parser_ (0),
    complex_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // struct_pskel
  //

  void struct_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void struct_pskel::
  simple_parser (::prf::simple_pskel& p)
  {
    this->simple_parser_ = &p;
  }

  void struct_pskel::
  configurationkind_parser (::prf::configurationKind_pskel& p)
  {
    this->configurationkind_parser_ = &p;
  }

  void struct_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void struct_pskel::
  mode_parser (::prf::AccessType_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void struct_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void struct_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::prf::simple_pskel& simple,
           ::prf::configurationKind_pskel& configurationkind,
           ::xml_schema::string_pskel& id,
           ::prf::AccessType_pskel& mode,
           ::xml_schema::string_pskel& name)
  {
    this->description_parser_ = &description;
    this->simple_parser_ = &simple;
    this->configurationkind_parser_ = &configurationkind;
    this->id_parser_ = &id;
    this->mode_parser_ = &mode;
    this->name_parser_ = &name;
  }

  struct_pskel::
  struct_pskel ()
  : description_parser_ (0),
    simple_parser_ (0),
    configurationkind_parser_ (0),
    id_parser_ (0),
    mode_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // structSequence_pskel
  //

  void structSequence_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void structSequence_pskel::
  struct_parser (::prf::struct_pskel& p)
  {
    this->struct__parser_ = &p;
  }

  void structSequence_pskel::
  structvalue_parser (::prf::structValue_pskel& p)
  {
    this->structvalue_parser_ = &p;
  }

  void structSequence_pskel::
  configurationkind_parser (::prf::configurationKind_pskel& p)
  {
    this->configurationkind_parser_ = &p;
  }

  void structSequence_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void structSequence_pskel::
  mode_parser (::prf::AccessType_pskel& p)
  {
    this->mode_parser_ = &p;
  }

  void structSequence_pskel::
  name_parser (::xml_schema::string_pskel& p)
  {
    this->name_parser_ = &p;
  }

  void structSequence_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::prf::struct_pskel& struct_,
           ::prf::structValue_pskel& structvalue,
           ::prf::configurationKind_pskel& configurationkind,
           ::xml_schema::string_pskel& id,
           ::prf::AccessType_pskel& mode,
           ::xml_schema::string_pskel& name)
  {
    this->description_parser_ = &description;
    this->struct__parser_ = &struct_;
    this->structvalue_parser_ = &structvalue;
    this->configurationkind_parser_ = &configurationkind;
    this->id_parser_ = &id;
    this->mode_parser_ = &mode;
    this->name_parser_ = &name;
  }

  structSequence_pskel::
  structSequence_pskel ()
  : description_parser_ (0),
    struct__parser_ (0),
    structvalue_parser_ (0),
    configurationkind_parser_ (0),
    id_parser_ (0),
    mode_parser_ (0),
    name_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // structValue_pskel
  //

  void structValue_pskel::
  simpleref_parser (::prf::simpleRef_pskel& p)
  {
    this->simpleref_parser_ = &p;
  }

  void structValue_pskel::
  parsers (::prf::simpleRef_pskel& simpleref)
  {
    this->simpleref_parser_ = &simpleref;
  }

  structValue_pskel::
  structValue_pskel ()
  : simpleref_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }

  // test_pskel
  //

  void test_pskel::
  description_parser (::xml_schema::string_pskel& p)
  {
    this->description_parser_ = &p;
  }

  void test_pskel::
  inputvalue_parser (::prf::inputValue_pskel& p)
  {
    this->inputvalue_parser_ = &p;
  }

  void test_pskel::
  resultvalue_parser (::prf::resultValue_pskel& p)
  {
    this->resultvalue_parser_ = &p;
  }

  void test_pskel::
  id_parser (::xml_schema::string_pskel& p)
  {
    this->id_parser_ = &p;
  }

  void test_pskel::
  parsers (::xml_schema::string_pskel& description,
           ::prf::inputValue_pskel& inputvalue,
           ::prf::resultValue_pskel& resultvalue,
           ::xml_schema::string_pskel& id)
  {
    this->description_parser_ = &description;
    this->inputvalue_parser_ = &inputvalue;
    this->resultvalue_parser_ = &resultvalue;
    this->id_parser_ = &id;
  }

  test_pskel::
  test_pskel ()
  : description_parser_ (0),
    inputvalue_parser_ (0),
    resultvalue_parser_ (0),
    id_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_),
    v_state_attr_stack_ (sizeof (v_state_attr_), &v_state_attr_first_)
  {
  }

  // values_pskel
  //

  void values_pskel::
  value_parser (::xml_schema::string_pskel& p)
  {
    this->value_parser_ = &p;
  }

  void values_pskel::
  parsers (::xml_schema::string_pskel& value)
  {
    this->value_parser_ = &value;
  }

  values_pskel::
  values_pskel ()
  : value_parser_ (0),
    v_state_stack_ (sizeof (v_state_), &v_state_first_)
  {
  }
}

namespace prf
{
  // Unit_pskel
  //

  ::std::string Unit_pskel::
  post_Unit ()
  {
    return post_string ();
  }

  // IsComplex_pskel
  //

  ::std::string IsComplex_pskel::
  post_IsComplex ()
  {
    return post_string ();
  }

  // AccessType_pskel
  //

  ::std::string AccessType_pskel::
  post_AccessType ()
  {
    return post_string ();
  }

  // action_pskel
  //

  void action_pskel::
  type (const ::std::string&)
  {
  }

  // ActionType_pskel
  //

  ::std::string ActionType_pskel::
  post_ActionType ()
  {
    return post_string ();
  }

  // configurationKind_pskel
  //

  void configurationKind_pskel::
  kindtype (const ::std::string&)
  {
  }

  // enumeration_pskel
  //

  void enumeration_pskel::
  label (const ::std::string&)
  {
  }

  void enumeration_pskel::
  value (const ::std::string&)
  {
  }

  // enumerations_pskel
  //

  void enumerations_pskel::
  enumeration (const ::std::map<std::string, std::string>::value_type&)
  {
  }

  // inputValue_pskel
  //

  void inputValue_pskel::
  simple (ossie::SimpleProperty*)
  {
  }

  void inputValue_pskel::
  post_inputValue ()
  {
  }

  // kind_pskel
  //

  void kind_pskel::
  kindtype (const ::std::string&)
  {
  }

  // PropertyConfigurationType_pskel
  //

  ::std::string PropertyConfigurationType_pskel::
  post_PropertyConfigurationType ()
  {
    return post_string ();
  }

  // StructPropertyConfigurationType_pskel
  //

  ::std::string StructPropertyConfigurationType_pskel::
  post_StructPropertyConfigurationType ()
  {
    return post_PropertyConfigurationType ();
  }

  // properties_pskel
  //

  void properties_pskel::
  description (const ::std::string&)
  {
  }

  void properties_pskel::
  simple (ossie::SimpleProperty*)
  {
  }

  void properties_pskel::
  simplesequence (ossie::SimpleSequenceProperty*)
  {
  }

  void properties_pskel::
  test ()
  {
  }

  void properties_pskel::
  struct_ (ossie::StructProperty*)
  {
  }

  void properties_pskel::
  structsequence (ossie::StructSequenceProperty*)
  {
  }

  // PropertyValueType_pskel
  //

  ::std::string PropertyValueType_pskel::
  post_PropertyValueType ()
  {
    return post_string ();
  }

  // range_pskel
  //

  void range_pskel::
  max (const ::std::string&)
  {
  }

  void range_pskel::
  min (const ::std::string&)
  {
  }

  // resultValue_pskel
  //

  void resultValue_pskel::
  simple (ossie::SimpleProperty*)
  {
  }

  void resultValue_pskel::
  post_resultValue ()
  {
  }

  // simple_pskel
  //

  void simple_pskel::
  description (const ::std::string&)
  {
  }

  void simple_pskel::
  value (const ::std::string&)
  {
  }

  void simple_pskel::
  units (const ::std::string&)
  {
  }

  void simple_pskel::
  range (const ::std::pair<std::string, std::string>&)
  {
  }

  void simple_pskel::
  enumerations (const ::std::map<std::string, std::string>&)
  {
  }

  void simple_pskel::
  kind (const ::std::string&)
  {
  }

  void simple_pskel::
  action (const ::std::string&)
  {
  }

  void simple_pskel::
  id (const ::std::string&)
  {
  }

  void simple_pskel::
  mode (const ::std::string&)
  {
  }

  void simple_pskel::
  name (const ::std::string&)
  {
  }

  void simple_pskel::
  complex (const ::std::string&)
  {
  }

  void simple_pskel::
  type (const ::std::string&)
  {
  }

  // simpleRef_pskel
  //

  void simpleRef_pskel::
  refid (const ::std::string&)
  {
  }

  void simpleRef_pskel::
  value (const ::std::string&)
  {
  }

  // simpleSequence_pskel
  //

  void simpleSequence_pskel::
  description (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  values (const ::std::vector<std::string>&)
  {
  }

  void simpleSequence_pskel::
  units (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  range (const ::std::pair<std::string, std::string>&)
  {
  }

  void simpleSequence_pskel::
  kind (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  action (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  id (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  mode (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  name (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  type (const ::std::string&)
  {
  }

  void simpleSequence_pskel::
  complex (const ::std::string&)
  {
  }

  // struct_pskel
  //

  void struct_pskel::
  description (const ::std::string&)
  {
  }

  void struct_pskel::
  simple (ossie::SimpleProperty*)
  {
  }

  void struct_pskel::
  configurationkind (const ::std::string&)
  {
  }

  void struct_pskel::
  id (const ::std::string&)
  {
  }

  void struct_pskel::
  mode (const ::std::string&)
  {
  }

  void struct_pskel::
  name (const ::std::string&)
  {
  }

  // structSequence_pskel
  //

  void structSequence_pskel::
  description (const ::std::string&)
  {
  }

  void structSequence_pskel::
  struct_ (ossie::StructProperty*)
  {
  }

  void structSequence_pskel::
  structvalue (const ::std::map<std::string, std::string>&)
  {
  }

  void structSequence_pskel::
  configurationkind (const ::std::string&)
  {
  }

  void structSequence_pskel::
  id (const ::std::string&)
  {
  }

  void structSequence_pskel::
  mode (const ::std::string&)
  {
  }

  void structSequence_pskel::
  name (const ::std::string&)
  {
  }

  // structValue_pskel
  //

  void structValue_pskel::
  simpleref (const ::std::map<std::string, std::string>::value_type&)
  {
  }

  // test_pskel
  //

  void test_pskel::
  description (const ::std::string&)
  {
  }

  void test_pskel::
  inputvalue ()
  {
  }

  void test_pskel::
  resultvalue ()
  {
  }

  void test_pskel::
  id (const ::std::string&)
  {
  }

  void test_pskel::
  post_test ()
  {
  }

  // values_pskel
  //

  void values_pskel::
  value (const ::std::string&)
  {
  }
}

#include <cassert>

namespace prf
{
  // Element validation and dispatch functions for enumerations_pskel.
  //
  bool enumerations_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "enumeration" && ns.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &enumerations_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "enumeration",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool enumerations_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void enumerations_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void enumerations_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "enumeration");

    this->v_state_stack_.pop ();
  }

  void enumerations_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "enumeration" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->enumeration_parser_;

            if (this->enumeration_parser_)
              this->enumeration_parser_->pre ();
          }
          else
          {
            if (this->enumeration_parser_)
            {
              const ::std::map<std::string, std::string>::value_type& tmp (this->enumeration_parser_->post_enumeration ());
              this->enumeration (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "enumeration",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for inputValue_pskel.
  //
  bool inputValue_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "simple" && ns.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &inputValue_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "simple",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool inputValue_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void inputValue_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void inputValue_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "simple");

    this->v_state_stack_.pop ();
  }

  void inputValue_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "simple" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;

            if (this->simple_parser_)
              this->simple_parser_->pre ();
          }
          else
          {
            if (this->simple_parser_)
            {
              ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
              this->simple (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "simple",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for properties_pskel.
  //
  bool properties_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if ((n == "simple" && ns.empty ()) ||
                 (n == "simplesequence" && ns.empty ()) ||
                 (n == "test" && ns.empty ()) ||
                 (n == "struct" && ns.empty ()) ||
                 (n == "structsequence" && ns.empty ()))
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &properties_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool properties_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void properties_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void properties_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void properties_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        unsigned long s (~0UL);

        if (n == "simple" && ns.empty ())
          s = 0UL;
        else if (n == "simplesequence" && ns.empty ())
          s = 1UL;
        else if (n == "test" && ns.empty ())
          s = 2UL;
        else if (n == "struct" && ns.empty ())
          s = 3UL;
        else if (n == "structsequence" && ns.empty ())
          s = 4UL;

        if (s != ~0UL)
        {
          assert (start);
          count++;

          v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
          v_state_descr_& vd = vs.data[vs.size++];

          vd.func = &properties_pskel::choice_0;
          vd.state = s;
          vd.count = 0;

          this->choice_0 (vd.state, vd.count, ns, n, t, true);
          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  void properties_pskel::
  choice_0 (unsigned long& state,
            unsigned long& count,
            const ::xml_schema::ro_string& ns,
            const ::xml_schema::ro_string& n,
            const ::xml_schema::ro_string* t,
            bool start)
  {
    XSD_UNUSED (count);
    XSD_UNUSED (ns);
    XSD_UNUSED (n);
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;

          if (this->simple_parser_)
            this->simple_parser_->pre ();
        }
        else
        {
          if (this->simple_parser_)
          {
            ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
            this->simple (tmp);
          }

          state = ~0UL;
        }

        break;
      }
      case 1UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->simplesequence_parser_;

          if (this->simplesequence_parser_)
            this->simplesequence_parser_->pre ();
        }
        else
        {
          if (this->simplesequence_parser_)
          {
            ossie::SimpleSequenceProperty* tmp (this->simplesequence_parser_->post_simpleSequence ());
            this->simplesequence (tmp);
          }

          state = ~0UL;
        }

        break;
      }
      case 2UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->test_parser_;

          if (this->test_parser_)
            this->test_parser_->pre ();
        }
        else
        {
          if (this->test_parser_)
          {
            this->test_parser_->post_test ();
            this->test ();
          }

          state = ~0UL;
        }

        break;
      }
      case 3UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->struct__parser_;

          if (this->struct__parser_)
            this->struct__parser_->pre ();
        }
        else
        {
          if (this->struct__parser_)
          {
            ossie::StructProperty* tmp (this->struct__parser_->post_struct ());
            this->struct_ (tmp);
          }

          state = ~0UL;
        }

        break;
      }
      case 4UL:
      {
        if (start)
        {
          this->::xml_schema::complex_content::context_.top ().parser_ = this->structsequence_parser_;

          if (this->structsequence_parser_)
            this->structsequence_parser_->pre ();
        }
        else
        {
          if (this->structsequence_parser_)
          {
            ossie::StructSequenceProperty* tmp (this->structsequence_parser_->post_structSequence ());
            this->structsequence (tmp);
          }

          state = ~0UL;
        }

        break;
      }
    }
  }

  // Element validation and dispatch functions for resultValue_pskel.
  //
  bool resultValue_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "simple" && ns.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &resultValue_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "simple",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool resultValue_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void resultValue_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void resultValue_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "simple");

    this->v_state_stack_.pop ();
  }

  void resultValue_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "simple" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;

            if (this->simple_parser_)
              this->simple_parser_->pre ();
          }
          else
          {
            if (this->simple_parser_)
            {
              ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
              this->simple (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "simple",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for simple_pskel.
  //
  bool simple_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if (n == "value" && ns.empty ())
          s = 1UL;
        else if (n == "units" && ns.empty ())
          s = 2UL;
        else if (n == "range" && ns.empty ())
          s = 3UL;
        else if (n == "enumerations" && ns.empty ())
          s = 4UL;
        else if (n == "kind" && ns.empty ())
          s = 5UL;
        else if (n == "action" && ns.empty ())
          s = 6UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &simple_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool simple_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void simple_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void simple_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void simple_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "value" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;

            if (this->value_parser_)
              this->value_parser_->pre ();
          }
          else
          {
            if (this->value_parser_)
            {
              const ::std::string& tmp (this->value_parser_->post_string ());
              this->value (tmp);
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "units" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->units_parser_;

            if (this->units_parser_)
              this->units_parser_->pre ();
          }
          else
          {
            if (this->units_parser_)
            {
              const ::std::string& tmp (this->units_parser_->post_Unit ());
              this->units (tmp);
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "range" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

            if (this->range_parser_)
              this->range_parser_->pre ();
          }
          else
          {
            if (this->range_parser_)
            {
              const ::std::pair<std::string, std::string>& tmp (this->range_parser_->post_range ());
              this->range (tmp);
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "enumerations" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->enumerations_parser_;

            if (this->enumerations_parser_)
              this->enumerations_parser_->pre ();
          }
          else
          {
            if (this->enumerations_parser_)
            {
              const ::std::map<std::string, std::string>& tmp (this->enumerations_parser_->post_enumerations ());
              this->enumerations (tmp);
            }

            count = 0;
            state = 5UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "kind" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->kind_parser_;

            if (this->kind_parser_)
              this->kind_parser_->pre ();
          }
          else
          {
            if (this->kind_parser_)
            {
              const ::std::string& tmp (this->kind_parser_->post_kind ());
              this->kind (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 6UL;
          // Fall through.
        }
      }
      case 6UL:
      {
        if (n == "action" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

            if (this->action_parser_)
              this->action_parser_->pre ();
          }
          else
          {
            if (this->action_parser_)
            {
              const ::std::string& tmp (this->action_parser_->post_action ());
              this->action (tmp);
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for simpleSequence_pskel.
  //
  bool simpleSequence_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if (n == "values" && ns.empty ())
          s = 1UL;
        else if (n == "units" && ns.empty ())
          s = 2UL;
        else if (n == "range" && ns.empty ())
          s = 3UL;
        else if (n == "kind" && ns.empty ())
          s = 4UL;
        else if (n == "action" && ns.empty ())
          s = 5UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &simpleSequence_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool simpleSequence_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void simpleSequence_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void simpleSequence_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }


    this->v_state_stack_.pop ();
  }

  void simpleSequence_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "values" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->values_parser_;

            if (this->values_parser_)
              this->values_parser_->pre ();
          }
          else
          {
            if (this->values_parser_)
            {
              const ::std::vector<std::string>& tmp (this->values_parser_->post_values ());
              this->values (tmp);
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "units" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->units_parser_;

            if (this->units_parser_)
              this->units_parser_->pre ();
          }
          else
          {
            if (this->units_parser_)
            {
              const ::std::string& tmp (this->units_parser_->post_Unit ());
              this->units (tmp);
            }

            count = 0;
            state = 3UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "range" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->range_parser_;

            if (this->range_parser_)
              this->range_parser_->pre ();
          }
          else
          {
            if (this->range_parser_)
            {
              const ::std::pair<std::string, std::string>& tmp (this->range_parser_->post_range ());
              this->range (tmp);
            }

            count = 0;
            state = 4UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 4UL;
          // Fall through.
        }
      }
      case 4UL:
      {
        if (n == "kind" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->kind_parser_;

            if (this->kind_parser_)
              this->kind_parser_->pre ();
          }
          else
          {
            if (this->kind_parser_)
            {
              const ::std::string& tmp (this->kind_parser_->post_kind ());
              this->kind (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 5UL;
          // Fall through.
        }
      }
      case 5UL:
      {
        if (n == "action" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->action_parser_;

            if (this->action_parser_)
              this->action_parser_->pre ();
          }
          else
          {
            if (this->action_parser_)
            {
              const ::std::string& tmp (this->action_parser_->post_action ());
              this->action (tmp);
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for struct_pskel.
  //
  bool struct_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if (n == "simple" && ns.empty ())
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &struct_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "description",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool struct_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void struct_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void struct_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "description");

    this->v_state_stack_.pop ();
  }

  void struct_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "simple" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->simple_parser_;

            if (this->simple_parser_)
              this->simple_parser_->pre ();
          }
          else
          {
            if (this->simple_parser_)
            {
              ossie::SimpleProperty* tmp (this->simple_parser_->post_simple ());
              this->simple (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "simple",
              ns, n);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "configurationkind" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->configurationkind_parser_;

            if (this->configurationkind_parser_)
              this->configurationkind_parser_->pre ();
          }
          else
          {
            if (this->configurationkind_parser_)
            {
              const ::std::string& tmp (this->configurationkind_parser_->post_configurationKind ());
              this->configurationkind (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for structSequence_pskel.
  //
  bool structSequence_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if (n == "struct" && ns.empty ())
          s = 1UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &structSequence_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "description",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool structSequence_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void structSequence_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void structSequence_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "description");

    this->v_state_stack_.pop ();
  }

  void structSequence_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "struct" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->struct__parser_;

            if (this->struct__parser_)
              this->struct__parser_->pre ();
          }
          else
          {
            if (this->struct__parser_)
            {
              ossie::StructProperty* tmp (this->struct__parser_->post_struct ());
              this->struct_ (tmp);
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "struct",
              ns, n);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "structvalue" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->structvalue_parser_;

            if (this->structvalue_parser_)
              this->structvalue_parser_->pre ();
          }
          else
          {
            if (this->structvalue_parser_)
            {
              const ::std::map<std::string, std::string>& tmp (this->structvalue_parser_->post_structValue ());
              this->structvalue (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 3UL;
          // Fall through.
        }
      }
      case 3UL:
      {
        if (n == "configurationkind" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->configurationkind_parser_;

            if (this->configurationkind_parser_)
              this->configurationkind_parser_->pre ();
          }
          else
          {
            if (this->configurationkind_parser_)
            {
              const ::std::string& tmp (this->configurationkind_parser_->post_configurationKind ());
              this->configurationkind (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for structValue_pskel.
  //
  bool structValue_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "simpleref" && ns.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &structValue_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "simpleref",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool structValue_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void structValue_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void structValue_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "simpleref");

    this->v_state_stack_.pop ();
  }

  void structValue_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "simpleref" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->simpleref_parser_;

            if (this->simpleref_parser_)
              this->simpleref_parser_->pre ();
          }
          else
          {
            if (this->simpleref_parser_)
            {
              const ::std::map<std::string, std::string>::value_type& tmp (this->simpleref_parser_->post_simpleRef ());
              this->simpleref (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "simpleref",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for test_pskel.
  //
  bool test_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "description" && ns.empty ())
          s = 0UL;
        else if (n == "inputvalue" && ns.empty ())
          s = 1UL;
        else if (n == "resultvalue" && ns.empty ())
          s = 2UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &test_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "description",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool test_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void test_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void test_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "description");

    this->v_state_stack_.pop ();
  }

  void test_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "description" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->description_parser_;

            if (this->description_parser_)
              this->description_parser_->pre ();
          }
          else
          {
            if (this->description_parser_)
            {
              const ::std::string& tmp (this->description_parser_->post_string ());
              this->description (tmp);
            }

            count = 0;
            state = 1UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 1UL;
          // Fall through.
        }
      }
      case 1UL:
      {
        if (n == "inputvalue" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->inputvalue_parser_;

            if (this->inputvalue_parser_)
              this->inputvalue_parser_->pre ();
          }
          else
          {
            if (this->inputvalue_parser_)
            {
              this->inputvalue_parser_->post_inputValue ();
              this->inputvalue ();
            }

            count = 0;
            state = 2UL;
          }

          break;
        }
        else
        {
          assert (start);
          count = 0;
          state = 2UL;
          // Fall through.
        }
      }
      case 2UL:
      {
        if (n == "resultvalue" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->resultvalue_parser_;

            if (this->resultvalue_parser_)
              this->resultvalue_parser_->pre ();
          }
          else
          {
            if (this->resultvalue_parser_)
            {
              this->resultvalue_parser_->post_resultValue ();
              this->resultvalue ();
            }

            count = 0;
            state = ~0UL;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "resultvalue",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }

  // Element validation and dispatch functions for values_pskel.
  //
  bool values_pskel::
  _start_element_impl (const ::xml_schema::ro_string& ns,
                       const ::xml_schema::ro_string& n,
                       const ::xml_schema::ro_string* t)
  {
    XSD_UNUSED (t);

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    if (vd->func == 0 && vd->state == 0)
    {
      if (this->::xml_schema::complex_content::_start_element_impl (ns, n, t))
        return true;
      else
        vd->state = 1;
    }

    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, ns, n, t, true);

      vd = vs.data + (vs.size - 1);

      if (vd->state == ~0UL)
        vd = vs.data + (--vs.size - 1);
      else
        break;
    }

    if (vd->func == 0)
    {
      if (vd->state != ~0UL)
      {
        unsigned long s = ~0UL;

        if (n == "value" && ns.empty ())
          s = 0UL;

        if (s != ~0UL)
        {
          vd->count++;
          vd->state = ~0UL;

          vd = vs.data + vs.size++;
          vd->func = &values_pskel::sequence_0;
          vd->state = s;
          vd->count = 0;

          this->sequence_0 (vd->state, vd->count, ns, n, t, true);
        }
        else
        {
          if (vd->count < 1UL)
            this->_expected_element (
              "", "value",
              ns, n);
          return false;
        }
      }
      else
        return false;
    }

    return true;
  }

  bool values_pskel::
  _end_element_impl (const ::xml_schema::ro_string& ns,
                     const ::xml_schema::ro_string& n)
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size - 1];

    if (vd.func == 0 && vd.state == 0)
    {
      if (!::xml_schema::complex_content::_end_element_impl (ns, n))
        assert (false);
      return true;
    }

    assert (vd.func != 0);
    (this->*vd.func) (vd.state, vd.count, ns, n, 0, false);

    if (vd.state == ~0UL)
      vs.size--;

    return true;
  }

  void values_pskel::
  _pre_e_validate ()
  {
    this->v_state_stack_.push ();
    static_cast< v_state_* > (this->v_state_stack_.top ())->size = 0;

    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_& vd = vs.data[vs.size++];

    vd.func = 0;
    vd.state = 0;
    vd.count = 0;
  }

  void values_pskel::
  _post_e_validate ()
  {
    v_state_& vs = *static_cast< v_state_* > (this->v_state_stack_.top ());
    v_state_descr_* vd = vs.data + (vs.size - 1);

    ::xml_schema::ro_string empty;
    while (vd->func != 0)
    {
      (this->*vd->func) (vd->state, vd->count, empty, empty, 0, true);
      assert (vd->state == ~0UL);
      vd = vs.data + (--vs.size - 1);
    }

    if (vd->count < 1UL)
      this->_expected_element (
        "", "value");

    this->v_state_stack_.pop ();
  }

  void values_pskel::
  sequence_0 (unsigned long& state,
              unsigned long& count,
              const ::xml_schema::ro_string& ns,
              const ::xml_schema::ro_string& n,
              const ::xml_schema::ro_string* t,
              bool start)
  {
    XSD_UNUSED (t);

    switch (state)
    {
      case 0UL:
      {
        if (n == "value" && ns.empty ())
        {
          if (start)
          {
            this->::xml_schema::complex_content::context_.top ().parser_ = this->value_parser_;

            if (this->value_parser_)
              this->value_parser_->pre ();
          }
          else
          {
            if (this->value_parser_)
            {
              const ::std::string& tmp (this->value_parser_->post_string ());
              this->value (tmp);
            }

            count++;
          }

          break;
        }
        else
        {
          assert (start);
          if (count < 1UL)
            this->_expected_element (
              "", "value",
              ns, n);
          count = 0;
          state = ~0UL;
          // Fall through.
        }
      }
      case ~0UL:
        break;
    }
  }
}

namespace prf
{
  // Attribute validation and dispatch functions for action_pskel.
  //
  bool action_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "type" && ns.empty ())
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_ActionType ());
        this->type (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for configurationKind_pskel.
  //
  bool configurationKind_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "kindtype" && ns.empty ())
    {
      if (this->kindtype_parser_)
      {
        this->kindtype_parser_->pre ();
        this->kindtype_parser_->_pre_impl ();
        this->kindtype_parser_->_characters (s);
        this->kindtype_parser_->_post_impl ();
        const ::std::string& tmp (this->kindtype_parser_->post_StructPropertyConfigurationType ());
        this->kindtype (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for enumeration_pskel.
  //
  bool enumeration_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "label" && ns.empty ())
    {
      if (this->label_parser_)
      {
        this->label_parser_->pre ();
        this->label_parser_->_pre_impl ();
        this->label_parser_->_characters (s);
        this->label_parser_->_post_impl ();
        const ::std::string& tmp (this->label_parser_->post_string ());
        this->label (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->label = true;
      return true;
    }

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();
        this->value_parser_->_pre_impl ();
        this->value_parser_->_characters (s);
        this->value_parser_->_post_impl ();
        const ::std::string& tmp (this->value_parser_->post_string ());
        this->value (tmp);
      }

      return true;
    }

    return false;
  }

  void enumeration_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.label = false;
  }

  void enumeration_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.label)
      this->_expected_attribute (
        "", "label");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for kind_pskel.
  //
  bool kind_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "kindtype" && ns.empty ())
    {
      if (this->kindtype_parser_)
      {
        this->kindtype_parser_->pre ();
        this->kindtype_parser_->_pre_impl ();
        this->kindtype_parser_->_characters (s);
        this->kindtype_parser_->_post_impl ();
        const ::std::string& tmp (this->kindtype_parser_->post_PropertyConfigurationType ());
        this->kindtype (tmp);
      }

      return true;
    }

    return false;
  }

  // Attribute validation and dispatch functions for range_pskel.
  //
  bool range_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "max" && ns.empty ())
    {
      if (this->max_parser_)
      {
        this->max_parser_->pre ();
        this->max_parser_->_pre_impl ();
        this->max_parser_->_characters (s);
        this->max_parser_->_post_impl ();
        const ::std::string& tmp (this->max_parser_->post_string ());
        this->max (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->max = true;
      return true;
    }

    if (n == "min" && ns.empty ())
    {
      if (this->min_parser_)
      {
        this->min_parser_->pre ();
        this->min_parser_->_pre_impl ();
        this->min_parser_->_characters (s);
        this->min_parser_->_post_impl ();
        const ::std::string& tmp (this->min_parser_->post_string ());
        this->min (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->min = true;
      return true;
    }

    return false;
  }

  void range_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.max = false;
    as.min = false;
  }

  void range_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.max)
      this->_expected_attribute (
        "", "max");
    if (!as.min)
      this->_expected_attribute (
        "", "min");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for simple_pskel.
  //
  bool simple_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
      {
        this->mode_parser_->pre ();
        this->mode_parser_->_pre_impl ();
        this->mode_parser_->_characters (s);
        this->mode_parser_->_post_impl ();
        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
        this->mode (tmp);
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      return true;
    }

    if (n == "complex" && ns.empty ())
    {
      if (this->complex_parser_)
      {
        this->complex_parser_->pre ();
        this->complex_parser_->_pre_impl ();
        this->complex_parser_->_characters (s);
        this->complex_parser_->_post_impl ();
        const ::std::string& tmp (this->complex_parser_->post_IsComplex ());
        this->complex (tmp);
      }

      return true;
    }

    if (n == "type" && ns.empty ())
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_PropertyValueType ());
        this->type (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
      return true;
    }

    return false;
  }

  void simple_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.type = false;
  }

  void simple_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.type)
      this->_expected_attribute (
        "", "type");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for simpleRef_pskel.
  //
  bool simpleRef_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "refid" && ns.empty ())
    {
      if (this->refid_parser_)
      {
        this->refid_parser_->pre ();
        this->refid_parser_->_pre_impl ();
        this->refid_parser_->_characters (s);
        this->refid_parser_->_post_impl ();
        const ::std::string& tmp (this->refid_parser_->post_string ());
        this->refid (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->refid = true;
      return true;
    }

    if (n == "value" && ns.empty ())
    {
      if (this->value_parser_)
      {
        this->value_parser_->pre ();
        this->value_parser_->_pre_impl ();
        this->value_parser_->_characters (s);
        this->value_parser_->_post_impl ();
        const ::std::string& tmp (this->value_parser_->post_string ());
        this->value (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->value = true;
      return true;
    }

    return false;
  }

  void simpleRef_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.refid = false;
    as.value = false;
  }

  void simpleRef_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.refid)
      this->_expected_attribute (
        "", "refid");
    if (!as.value)
      this->_expected_attribute (
        "", "value");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for simpleSequence_pskel.
  //
  bool simpleSequence_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
      {
        this->mode_parser_->pre ();
        this->mode_parser_->_pre_impl ();
        this->mode_parser_->_characters (s);
        this->mode_parser_->_post_impl ();
        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
        this->mode (tmp);
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      return true;
    }

    if (n == "type" && ns.empty ())
    {
      if (this->type_parser_)
      {
        this->type_parser_->pre ();
        this->type_parser_->_pre_impl ();
        this->type_parser_->_characters (s);
        this->type_parser_->_post_impl ();
        const ::std::string& tmp (this->type_parser_->post_PropertyValueType ());
        this->type (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->type = true;
      return true;
    }

    if (n == "complex" && ns.empty ())
    {
      if (this->complex_parser_)
      {
        this->complex_parser_->pre ();
        this->complex_parser_->_pre_impl ();
        this->complex_parser_->_characters (s);
        this->complex_parser_->_post_impl ();
        const ::std::string& tmp (this->complex_parser_->post_IsComplex ());
        this->complex (tmp);
      }

      return true;
    }

    return false;
  }

  void simpleSequence_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
    as.type = false;
  }

  void simpleSequence_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");
    if (!as.type)
      this->_expected_attribute (
        "", "type");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for struct_pskel.
  //
  bool struct_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
      {
        this->mode_parser_->pre ();
        this->mode_parser_->_pre_impl ();
        this->mode_parser_->_characters (s);
        this->mode_parser_->_post_impl ();
        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
        this->mode (tmp);
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      return true;
    }

    return false;
  }

  void struct_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
  }

  void struct_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for structSequence_pskel.
  //
  bool structSequence_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    if (n == "mode" && ns.empty ())
    {
      if (this->mode_parser_)
      {
        this->mode_parser_->pre ();
        this->mode_parser_->_pre_impl ();
        this->mode_parser_->_characters (s);
        this->mode_parser_->_post_impl ();
        const ::std::string& tmp (this->mode_parser_->post_AccessType ());
        this->mode (tmp);
      }

      return true;
    }

    if (n == "name" && ns.empty ())
    {
      if (this->name_parser_)
      {
        this->name_parser_->pre ();
        this->name_parser_->_pre_impl ();
        this->name_parser_->_characters (s);
        this->name_parser_->_post_impl ();
        const ::std::string& tmp (this->name_parser_->post_string ());
        this->name (tmp);
      }

      return true;
    }

    return false;
  }

  void structSequence_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
  }

  void structSequence_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");

    this->v_state_attr_stack_.pop ();
  }

  // Attribute validation and dispatch functions for test_pskel.
  //
  bool test_pskel::
  _attribute_impl_phase_one (const ::xml_schema::ro_string& ns,
                             const ::xml_schema::ro_string& n,
                             const ::xml_schema::ro_string& s)
  {
    if (n == "id" && ns.empty ())
    {
      if (this->id_parser_)
      {
        this->id_parser_->pre ();
        this->id_parser_->_pre_impl ();
        this->id_parser_->_characters (s);
        this->id_parser_->_post_impl ();
        const ::std::string& tmp (this->id_parser_->post_string ());
        this->id (tmp);
      }

      static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ())->id = true;
      return true;
    }

    return false;
  }

  void test_pskel::
  _pre_a_validate ()
  {
    this->v_state_attr_stack_.push ();
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    as.id = false;
  }

  void test_pskel::
  _post_a_validate ()
  {
    v_state_attr_& as = *static_cast< v_state_attr_* > (this->v_state_attr_stack_.top ());

    if (!as.id)
      this->_expected_attribute (
        "", "id");

    this->v_state_attr_stack_.pop ();
  }
}

namespace prf
{
}

// Begin epilogue.
//
//
// End epilogue.

